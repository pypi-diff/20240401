# Comparing `tmp/pciSeq-0.0.61.dev2-py3-none-any.whl.zip` & `tmp/pciSeq-0.0.61.dev3-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,70 +1,70 @@
-Zip file size: 353197 bytes, number of entries: 68
--rw-rw-r--  2.0 unx     1731 b- defN 24-Feb-28 11:21 pciSeq/__init__.py
--rw-rw-r--  2.0 unx       27 b- defN 24-Feb-28 21:15 pciSeq/_version.py
--rw-rw-r--  2.0 unx    12064 b- defN 24-Feb-28 21:15 pciSeq/app.py
--rw-rw-r--  2.0 unx     4474 b- defN 24-Feb-28 21:11 pciSeq/config.py
+Zip file size: 353720 bytes, number of entries: 68
+-rw-rw-r--  2.0 unx     1731 b- defN 24-Mar-25 22:38 pciSeq/__init__.py
+-rw-rw-r--  2.0 unx       27 b- defN 24-Apr-01 11:01 pciSeq/_version.py
+-rw-rw-r--  2.0 unx    12905 b- defN 24-Apr-01 10:51 pciSeq/app.py
+-rw-rw-r--  2.0 unx     3912 b- defN 24-Apr-01 10:51 pciSeq/config.py
 -rw-rw-r--  2.0 unx        0 b- defN 23-Sep-30 22:43 pciSeq/src/__init__.py
--rw-rw-r--  2.0 unx        0 b- defN 24-Feb-27 22:45 pciSeq/src/core/__init__.py
--rw-rw-r--  2.0 unx    23731 b- defN 24-Feb-28 21:15 pciSeq/src/core/datatypes.py
--rw-rw-r--  2.0 unx      588 b- defN 24-Feb-27 22:52 pciSeq/src/core/logger.py
--rw-rw-r--  2.0 unx    20254 b- defN 24-Feb-28 21:15 pciSeq/src/core/main.py
--rw-rw-r--  2.0 unx     3330 b- defN 24-Feb-28 21:15 pciSeq/src/core/summary.py
--rw-rw-r--  2.0 unx     8589 b- defN 24-Feb-28 21:15 pciSeq/src/core/utils.py
+-rw-rw-r--  2.0 unx        0 b- defN 24-Mar-25 22:38 pciSeq/src/core/__init__.py
+-rw-rw-r--  2.0 unx    21229 b- defN 24-Apr-01 10:51 pciSeq/src/core/datatypes.py
+-rw-rw-r--  2.0 unx      588 b- defN 24-Mar-27 23:42 pciSeq/src/core/logger.py
+-rw-rw-r--  2.0 unx    20021 b- defN 24-Apr-01 10:51 pciSeq/src/core/main.py
+-rw-rw-r--  2.0 unx     3330 b- defN 24-Apr-01 10:51 pciSeq/src/core/summary.py
+-rw-rw-r--  2.0 unx     9656 b- defN 24-Apr-01 10:51 pciSeq/src/core/utils.py
 -rw-rw-r--  2.0 unx        0 b- defN 24-Feb-27 22:45 pciSeq/src/diagnostics/__init__.py
--rw-rw-r--  2.0 unx      191 b- defN 24-Feb-27 22:52 pciSeq/src/diagnostics/config.py
--rw-rw-r--  2.0 unx     3277 b- defN 24-Feb-27 22:52 pciSeq/src/diagnostics/diagnostics.py
--rw-rw-r--  2.0 unx      708 b- defN 24-Feb-27 22:52 pciSeq/src/diagnostics/launch_diagnostics.py
--rw-rw-r--  2.0 unx     7173 b- defN 24-Feb-27 22:52 pciSeq/src/diagnostics/utils.py
+-rw-rw-r--  2.0 unx      191 b- defN 24-Mar-25 22:38 pciSeq/src/diagnostics/config.py
+-rw-rw-r--  2.0 unx     3277 b- defN 24-Mar-25 22:38 pciSeq/src/diagnostics/diagnostics.py
+-rw-rw-r--  2.0 unx     1904 b- defN 24-Apr-01 10:51 pciSeq/src/diagnostics/launch_diagnostics.py
+-rw-rw-r--  2.0 unx     7173 b- defN 24-Mar-25 22:38 pciSeq/src/diagnostics/utils.py
 -rw-rw-r--  2.0 unx        0 b- defN 23-Sep-30 22:43 pciSeq/src/preprocess/__init__.py
--rw-rw-r--  2.0 unx     3356 b- defN 24-Feb-27 22:52 pciSeq/src/preprocess/cell_borders.py
--rw-rw-r--  2.0 unx     4603 b- defN 24-Feb-28 11:21 pciSeq/src/preprocess/spot_labels.py
--rw-rw-r--  2.0 unx       84 b- defN 24-Feb-28 11:21 pciSeq/src/preprocess/utils.py
+-rw-rw-r--  2.0 unx     3760 b- defN 24-Mar-25 22:38 pciSeq/src/preprocess/cell_borders.py
+-rw-rw-r--  2.0 unx     4932 b- defN 24-Apr-01 10:51 pciSeq/src/preprocess/spot_labels.py
+-rw-rw-r--  2.0 unx       84 b- defN 24-Apr-01 10:51 pciSeq/src/preprocess/utils.py
 -rw-rw-r--  2.0 unx        0 b- defN 23-Sep-30 22:43 pciSeq/src/viewer/__init__.py
--rw-rw-r--  2.0 unx     2151 b- defN 24-Feb-27 22:52 pciSeq/src/viewer/run_flask.py
--rw-rw-r--  2.0 unx     4046 b- defN 24-Feb-28 11:21 pciSeq/src/viewer/stage_image.py
--rw-rw-r--  2.0 unx     9157 b- defN 24-Feb-28 21:15 pciSeq/src/viewer/utils.py
--rw-rw-r--  2.0 unx     9107 b- defN 24-Feb-27 22:52 pciSeq/static/2D/index.html
--rw-rw-r--  2.0 unx     6335 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/genes_datatable.html
--rw-rw-r--  2.0 unx     8479 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/css/index.css
--rw-rw-r--  2.0 unx     2977 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/css/progress.css
--rw-rw-r--  2.0 unx     7613 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/classConfig.js
--rw-rw-r--  2.0 unx     2337 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/config.js
--rw-rw-r--  2.0 unx     5422 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/customControl.js
--rw-rw-r--  2.0 unx    22862 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/dapi.js
--rw-rw-r--  2.0 unx     5842 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/dataLoader.js
--rw-rw-r--  2.0 unx    16704 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/donut.js
--rw-rw-r--  2.0 unx     3986 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/dt.js
--rw-rw-r--  2.0 unx     9678 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/glyphConfig.js
--rw-rw-r--  2.0 unx     4234 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/glyphPaths.js
--rw-rw-r--  2.0 unx     6996 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/glyphs.js
--rw-rw-r--  2.0 unx    11916 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/index.js
--rw-rw-r--  2.0 unx     1046 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/progress.js
--rw-rw-r--  2.0 unx     6206 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/stage_cells.js
--rw-rw-r--  2.0 unx    11715 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/stage_glyphs.js
--rw-rw-r--  2.0 unx     7408 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/stage_markers_patched.js
--rw-rw-r--  2.0 unx    14941 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/stage_polygons.js
--rw-rw-r--  2.0 unx     4330 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/streaming-tsv-parser.js
--rw-rw-r--  2.0 unx     4557 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/viewerUtils.js
--rw-rw-r--  2.0 unx      933 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/lib/css/L.Control.Layers.Tree.css
--rw-rw-r--  2.0 unx      421 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/lib/css/Leaflet.Coordinates-0.1.3.css
--rw-rw-r--  2.0 unx   122540 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/lib/css/bootstrap.min.css
--rw-rw-r--  2.0 unx     8238 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/lib/css/index.css
--rw-rw-r--  2.0 unx     1161 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/lib/css/keen-dashboards.css
--rw-rw-r--  2.0 unx     4960 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/lib/css/screen.css
--rw-rw-r--  2.0 unx    26007 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/lib/js/L.Control.Layers.Tree.js
--rw-rw-r--  2.0 unx     8488 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/lib/js/Leaflet.Coordinates-0.1.3.src.js
--rw-rw-r--  2.0 unx    31819 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/lib/js/bootstrap.min.js
--rw-rw-r--  2.0 unx    42706 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/lib/js/keen.min.js
--rw-rw-r--  2.0 unx    14928 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/lib/js/leaflet-pip.js
--rw-rw-r--  2.0 unx     5753 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/lib/js/leaflet.textpath.js
--rw-rw-r--  2.0 unx      257 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/lib/js/preloader.js
--rw-rw-r--  2.0 unx     8784 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/lib/js/pixiOverlay/MarkerContainer.js
--rw-rw-r--  2.0 unx     4323 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/lib/js/pixiOverlay/bezier-easing.js
--rw-rw-r--  2.0 unx   613808 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/lib/js/pixiOverlay/example.min.js
--rw-rw-r--  2.0 unx    91874 b- defN 24-Feb-27 22:45 pciSeq/static/2D/viewer/js/lib/js/pixiOverlay/tools.min.js
--rw-rw-r--  2.0 unx     1073 b- defN 24-Feb-28 21:15 pciSeq-0.0.61.dev2.dist-info/LICENCE
--rw-rw-r--  2.0 unx     6325 b- defN 24-Feb-28 21:15 pciSeq-0.0.61.dev2.dist-info/METADATA
--rw-rw-r--  2.0 unx       92 b- defN 24-Feb-28 21:15 pciSeq-0.0.61.dev2.dist-info/WHEEL
--rw-rw-r--  2.0 unx        7 b- defN 24-Feb-28 21:15 pciSeq-0.0.61.dev2.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     6461 b- defN 24-Feb-28 21:15 pciSeq-0.0.61.dev2.dist-info/RECORD
-68 files, 1285183 bytes uncompressed, 342703 bytes compressed:  73.3%
+-rw-rw-r--  2.0 unx     2151 b- defN 24-Apr-01 10:51 pciSeq/src/viewer/run_flask.py
+-rw-rw-r--  2.0 unx     4046 b- defN 24-Mar-25 22:38 pciSeq/src/viewer/stage_image.py
+-rw-rw-r--  2.0 unx     9157 b- defN 24-Apr-01 10:51 pciSeq/src/viewer/utils.py
+-rw-rw-r--  2.0 unx     9107 b- defN 24-Apr-01 10:51 pciSeq/static/2D/index.html
+-rw-rw-r--  2.0 unx     6732 b- defN 24-Apr-01 10:51 pciSeq/static/2D/viewer/genes_datatable.html
+-rw-rw-r--  2.0 unx     8479 b- defN 24-Mar-25 22:38 pciSeq/static/2D/viewer/css/index.css
+-rw-rw-r--  2.0 unx     2977 b- defN 24-Mar-25 22:38 pciSeq/static/2D/viewer/css/progress.css
+-rw-rw-r--  2.0 unx     7613 b- defN 24-Apr-01 10:51 pciSeq/static/2D/viewer/js/classConfig.js
+-rw-rw-r--  2.0 unx     2337 b- defN 24-Apr-01 10:51 pciSeq/static/2D/viewer/js/config.js
+-rw-rw-r--  2.0 unx     5422 b- defN 24-Mar-25 22:38 pciSeq/static/2D/viewer/js/customControl.js
+-rw-rw-r--  2.0 unx    23037 b- defN 24-Apr-01 10:51 pciSeq/static/2D/viewer/js/dapi.js
+-rw-rw-r--  2.0 unx     5842 b- defN 24-Mar-25 22:38 pciSeq/static/2D/viewer/js/dataLoader.js
+-rw-rw-r--  2.0 unx    16875 b- defN 24-Apr-01 10:51 pciSeq/static/2D/viewer/js/donut.js
+-rw-rw-r--  2.0 unx     3986 b- defN 24-Mar-25 22:38 pciSeq/static/2D/viewer/js/dt.js
+-rw-rw-r--  2.0 unx     9678 b- defN 24-Apr-01 10:51 pciSeq/static/2D/viewer/js/glyphConfig.js
+-rw-rw-r--  2.0 unx     4234 b- defN 24-Mar-25 22:38 pciSeq/static/2D/viewer/js/glyphPaths.js
+-rw-rw-r--  2.0 unx     6996 b- defN 24-Mar-25 22:38 pciSeq/static/2D/viewer/js/glyphs.js
+-rw-rw-r--  2.0 unx    11916 b- defN 24-Apr-01 10:51 pciSeq/static/2D/viewer/js/index.js
+-rw-rw-r--  2.0 unx     1046 b- defN 24-Mar-25 22:38 pciSeq/static/2D/viewer/js/progress.js
+-rw-rw-r--  2.0 unx     6206 b- defN 24-Mar-25 22:38 pciSeq/static/2D/viewer/js/stage_cells.js
+-rw-rw-r--  2.0 unx    11808 b- defN 24-Apr-01 10:51 pciSeq/static/2D/viewer/js/stage_glyphs.js
+-rw-rw-r--  2.0 unx     7408 b- defN 24-Apr-01 10:51 pciSeq/static/2D/viewer/js/stage_markers_patched.js
+-rw-rw-r--  2.0 unx    14941 b- defN 24-Apr-01 10:51 pciSeq/static/2D/viewer/js/stage_polygons.js
+-rw-rw-r--  2.0 unx     4330 b- defN 24-Mar-25 22:38 pciSeq/static/2D/viewer/js/streaming-tsv-parser.js
+-rw-rw-r--  2.0 unx     4557 b- defN 24-Mar-25 22:38 pciSeq/static/2D/viewer/js/viewerUtils.js
+-rw-rw-r--  2.0 unx      933 b- defN 24-Mar-25 22:38 pciSeq/static/2D/viewer/js/lib/css/L.Control.Layers.Tree.css
+-rw-rw-r--  2.0 unx      421 b- defN 24-Mar-25 22:38 pciSeq/static/2D/viewer/js/lib/css/Leaflet.Coordinates-0.1.3.css
+-rw-rw-r--  2.0 unx   122540 b- defN 24-Mar-25 22:38 pciSeq/static/2D/viewer/js/lib/css/bootstrap.min.css
+-rw-rw-r--  2.0 unx     8238 b- defN 24-Mar-25 22:38 pciSeq/static/2D/viewer/js/lib/css/index.css
+-rw-rw-r--  2.0 unx     1161 b- defN 24-Mar-25 22:38 pciSeq/static/2D/viewer/js/lib/css/keen-dashboards.css
+-rw-rw-r--  2.0 unx     4960 b- defN 24-Mar-25 22:38 pciSeq/static/2D/viewer/js/lib/css/screen.css
+-rw-rw-r--  2.0 unx    26007 b- defN 24-Mar-25 22:38 pciSeq/static/2D/viewer/js/lib/js/L.Control.Layers.Tree.js
+-rw-rw-r--  2.0 unx     8488 b- defN 24-Mar-25 22:38 pciSeq/static/2D/viewer/js/lib/js/Leaflet.Coordinates-0.1.3.src.js
+-rw-rw-r--  2.0 unx    31819 b- defN 24-Mar-25 22:38 pciSeq/static/2D/viewer/js/lib/js/bootstrap.min.js
+-rw-rw-r--  2.0 unx    42706 b- defN 24-Mar-25 22:38 pciSeq/static/2D/viewer/js/lib/js/keen.min.js
+-rw-rw-r--  2.0 unx    14928 b- defN 24-Mar-25 22:38 pciSeq/static/2D/viewer/js/lib/js/leaflet-pip.js
+-rw-rw-r--  2.0 unx     5753 b- defN 24-Mar-25 22:38 pciSeq/static/2D/viewer/js/lib/js/leaflet.textpath.js
+-rw-rw-r--  2.0 unx      257 b- defN 24-Mar-25 22:38 pciSeq/static/2D/viewer/js/lib/js/preloader.js
+-rw-rw-r--  2.0 unx     8784 b- defN 24-Mar-25 22:38 pciSeq/static/2D/viewer/js/lib/js/pixiOverlay/MarkerContainer.js
+-rw-rw-r--  2.0 unx     4323 b- defN 24-Mar-25 22:38 pciSeq/static/2D/viewer/js/lib/js/pixiOverlay/bezier-easing.js
+-rw-rw-r--  2.0 unx   613808 b- defN 24-Mar-25 22:38 pciSeq/static/2D/viewer/js/lib/js/pixiOverlay/example.min.js
+-rw-rw-r--  2.0 unx    91874 b- defN 24-Mar-25 22:38 pciSeq/static/2D/viewer/js/lib/js/pixiOverlay/tools.min.js
+-rw-rw-r--  2.0 unx     1073 b- defN 24-Apr-01 11:02 pciSeq-0.0.61.dev3.dist-info/LICENCE
+-rw-rw-r--  2.0 unx     6346 b- defN 24-Apr-01 11:02 pciSeq-0.0.61.dev3.dist-info/METADATA
+-rw-rw-r--  2.0 unx       92 b- defN 24-Apr-01 11:02 pciSeq-0.0.61.dev3.dist-info/WHEEL
+-rw-rw-r--  2.0 unx        7 b- defN 24-Apr-01 11:02 pciSeq-0.0.61.dev3.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     6462 b- defN 24-Apr-01 11:02 pciSeq-0.0.61.dev3.dist-info/RECORD
+68 files, 1286581 bytes uncompressed, 343226 bytes compressed:  73.3%
```

## zipnote {}

```diff
@@ -183,23 +183,23 @@
 
 Filename: pciSeq/static/2D/viewer/js/lib/js/pixiOverlay/example.min.js
 Comment: 
 
 Filename: pciSeq/static/2D/viewer/js/lib/js/pixiOverlay/tools.min.js
 Comment: 
 
-Filename: pciSeq-0.0.61.dev2.dist-info/LICENCE
+Filename: pciSeq-0.0.61.dev3.dist-info/LICENCE
 Comment: 
 
-Filename: pciSeq-0.0.61.dev2.dist-info/METADATA
+Filename: pciSeq-0.0.61.dev3.dist-info/METADATA
 Comment: 
 
-Filename: pciSeq-0.0.61.dev2.dist-info/WHEEL
+Filename: pciSeq-0.0.61.dev3.dist-info/WHEEL
 Comment: 
 
-Filename: pciSeq-0.0.61.dev2.dist-info/top_level.txt
+Filename: pciSeq-0.0.61.dev3.dist-info/top_level.txt
 Comment: 
 
-Filename: pciSeq-0.0.61.dev2.dist-info/RECORD
+Filename: pciSeq-0.0.61.dev3.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## pciSeq/_version.py

```diff
@@ -1 +1 @@
-__version__ = '0.0.61.dev2'
+__version__ = '0.0.61.dev3'
```

## pciSeq/app.py

```diff
@@ -178,14 +178,15 @@
     """
     Reads the opts dict and if not None, it will override the default parameter value by
     the value that the dictionary key points to.
     If opts is None, then the default values as these specified in the config.py file
     are used without any change.
     """
     cfg = config.DEFAULT
+    log_file(cfg)
     cfg['is_redis_running'] = check_redis_server()
     if opts is not None:
         default_items = set(cfg.keys())
         user_items = set(opts.keys())
         assert user_items.issubset(default_items), ('Options passed-in should be a dict with keys: %s ' % default_items)
         for item in opts.items():
             if isinstance(item[1], (int, float, list, str)) or isinstance(item[1](1), np.floating):
@@ -195,14 +196,31 @@
             else:
                 raise TypeError("Only integers, floats and lists are allowed")
             cfg[item[0]] = val
             app_logger.info('%s is set to %s' % (item[0], cfg[item[0]]))
     return cfg
 
 
+def log_file(cfg):
+    """
+    Setup the logger file handler.
+    Ideally that should happen when the logger is first configured, hence avoid having
+    the console handler and the file handler set up in two different places. However
+    the file handler needs access to the config dict and that was not possible until
+    this point into the program.
+    """
+    logfile = os.path.join(get_out_dir(cfg['output_path']), 'pciSeq.log')
+    fh = logging.FileHandler(logfile, mode='w')
+    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
+    fh.setFormatter(formatter)
+
+    logging.getLogger().addHandler(fh)
+    app_logger.info('Writing to %s' % logfile)
+
+
 def validate(spots, coo, sc, cfg):
     assert isinstance(spots, pd.DataFrame) and set(spots.columns) == {'Gene', 'x', 'y'}, \
         "Spots should be passed-in to the fit() method as a dataframe with columns ['Gene', 'x', 'y']"
 
     assert isinstance(coo, coo_matrix), 'The segmentation masks should be passed-in as a coo_matrix'
 
     if sc is not None:
@@ -224,14 +242,20 @@
 
     if cfg['cell_type_prior'].lower() not in ['uniform'.lower(), 'weighted'.lower()]:
         raise ValueError("'cel_type_prior' should be either 'uniform' or 'weighted' ")
 
     # make sure the string is lowercase from now on
     cfg['cell_type_prior'] = cfg['cell_type_prior'].lower()
 
+    # do some datatype casting
+    spots = spots.astype({
+        'Gene': str,
+        'x': np.float32,
+        'y': np.float32})
+
     return cfg, spots
 
 
 def purge_spots(spots, sc):
     drop_spots = list(set(spots.Gene) - set(sc.index))
     app_logger.warning('Found %d genes that are not included in the single cell data' % len(drop_spots))
     idx = ~ np.in1d(spots.Gene, drop_spots)
```

## pciSeq/config.py

```diff
@@ -56,22 +56,14 @@
     'launch_viewer': False,
 
     'launch_diagnostics': True,
 
     # Initialise this to False, the correct value is set internally by the code itself
     'is_redis_running': False,
 
-    # Use either np.float16 or np.float32 to reduce memory usage. In most cases RAM consumption shouldnt
-    # need more than 32Gb RAM. If you have a dataset from a full coronal mouse slice with a high number of
-    # segmented cells (around 150,000) a gene panel of more than 250 genes and 100 or more different
-    # cell types (aka clusters, aka classes) in the single cell data then you might need at least 64GB on
-    # your machine. Changing the datatype to a float16 or float32 will help keeping RAM usage to a lower
-    # level
-    'dtype': np.float64,
-
     # cell radius. If None then pciSeq will calc that as the mean radius across all cells.
     # Otherwise it will use the value provided below
     'cell_radius': None,
 
     # cell type prior: The prior distribution on the classes. It expresses the view on
     # how likely each class is to occur a-priori. It can be either 'uniform' or 'weighted'
     # 'uniform' means that the Zero class gets 50% and the remaining 50% is equally split
```

## pciSeq/src/core/datatypes.py

```diff
@@ -1,25 +1,25 @@
-import sys
+import scipy
 import numpy as np
 import pandas as pd
-import scipy
-import numexpr as ne
+import dask
 import numpy_groupies as npg
 from natsort import natsort_keygen
+from .utils import read_image_objects, keep_labels_unique
 from sklearn.neighbors import NearestNeighbors
 import logging
 
 datatypes_logger = logging.getLogger(__name__)
 
 
 class Cells(object):
     # Get rid of the properties where not necessary!!
     def __init__(self, _cells_df, config):
         self.config = config
-        self.ini_cell_props, self._mcr = self.read_image_objects(_cells_df, config)
+        self.ini_cell_props, self._mcr = read_image_objects(_cells_df, config)
         self.nC = len(self.ini_cell_props['cell_label'])
         self.classProb = None
         self.class_names = None
         self._cov = self.ini_cov()
         self.nu_0 = config['mean_gene_counts_per_cell']
         self._centroid = self.ini_centroids()
         self._gene_counts = None
@@ -61,15 +61,14 @@
     @centroid.setter
     def centroid(self, df):
         assert isinstance(df, pd.DataFrame), 'Input should be a dataframe'
         assert set(df.columns.values) == {'x', 'y'}, 'Dataframe columns should be ''x'', ''y'' '
         df.index.name = 'cell_label'
         self._centroid = df.copy()
 
-
     @property
     def cov(self):
         return self._cov
 
     @cov.setter
     def cov(self, val):
         self._cov = val
@@ -78,27 +77,26 @@
     def mcr(self):
         if self.config['cell_radius'] is not None:
             r = self.config['cell_radius']
         else:
             r = self._mcr
         return r
 
-
     # -------- METHODS -------- #
     def ini_centroids(self):
         d = {
             'x': self.ini_cell_props['x0'],
             'y': self.ini_cell_props['y0'],
         }
         df = pd.DataFrame(d)
         return df.copy()
 
     def ini_cov(self):
         mcr = self.mcr
-        cov = mcr * mcr * np.eye(2, 2)
+        cov = mcr * mcr * np.eye(2, 2, dtype=np.float32)
         return np.tile(cov, (self.nC, 1, 1))
 
     # def dapi_mean_cell_radius(self):
     #     return np.nanmean(np.sqrt(self.ini_cell_props['area'] / np.pi)) * 0.5
 
     def nn(self):
         n = self.config['nNeighbors'] + 1
@@ -134,47 +132,16 @@
         # Return now the scatter matrix. Some cell might not have any spots nearby. For those empty cells,
         # the scatter matrix will be a squared zero array. That is fine.
         out[:, 0, 0] = agg_00
         out[:, 1, 1] = agg_11
         out[:, 0, 1] = agg_01
         out[:, 1, 0] = agg_01
 
-        return out
+        return out.astype(np.float32)
 
-    def read_image_objects(self, img_obj, cfg):
-        meanCellRadius = np.mean(np.sqrt(img_obj.area / np.pi)) * 0.5
-        relCellRadius = np.sqrt(img_obj.area / np.pi) / meanCellRadius
-
-        # append 1 for the misreads
-        relCellRadius = np.append(1, relCellRadius)
-
-        InsideCellBonus = cfg['InsideCellBonus']
-        if not InsideCellBonus:
-            # This is more for clarity. The operation below will work fine even if InsideCellBonus is False
-            InsideCellBonus = 0
-
-        # if InsideCellBonus == 0 then CellAreaFactor will be equal to 1.0
-        numer = np.exp(-relCellRadius ** 2 / 2) * (1 - np.exp(InsideCellBonus)) + np.exp(InsideCellBonus)
-        denom = np.exp(-0.5) * (1 - np.exp(InsideCellBonus)) + np.exp(InsideCellBonus)
-        CellAreaFactor = numer / denom
-
-        out = {}
-        out['area_factor'] = CellAreaFactor
-        out['rel_radius'] = relCellRadius
-        out['area'] = np.append(np.nan, img_obj.area)
-        out['x0'] = np.append(-sys.maxsize, img_obj.x0.values)
-        out['y0'] = np.append(-sys.maxsize, img_obj.y0.values)
-        out['cell_label'] = np.append(0, img_obj.label.values)
-        if 'old_label' in img_obj.columns:
-            out['cell_label_old'] = np.append(0, img_obj.old_label.values)
-        # First cell is a dummy cell, a super neighbour (ie always a neighbour to any given cell)
-        # and will be used to get all the misreads. It was given the label=0 and some very small
-        # negative coords
-
-        return out, meanCellRadius
 
 # ----------------------------------------Class: Genes--------------------------------------------------- #
 class Genes(object):
     def __init__(self, spots):
         self.gene_panel = np.unique(spots.data.gene_name.values)
         self._eta_bar = None
         self._logeta_bar = None
@@ -185,71 +152,84 @@
         return self._eta_bar
 
     @property
     def logeta_bar(self):
         return self._logeta_bar
 
     def init_eta(self, a, b):
-        self._eta_bar = np.ones(self.nG) * (a / b)
-        self._logeta_bar = np.ones(self.nG) * self._digamma(a, b)
+        self._eta_bar = np.ones(self.nG, dtype=np.float32) * (a / b)
+        self._logeta_bar = np.ones(self.nG, dtype=np.float32) * self._digamma(a, b)
 
     def calc_eta(self, a, b):
-        self._eta_bar = a/b
+        a = a.astype(np.float32)
+        b = b.astype(np.float32)
+        self._eta_bar = a / b
         self._logeta_bar = self._digamma(a, b)
 
     def _digamma(self, a, b):
         return scipy.special.psi(a) - np.log(b)
 
 
 # ----------------------------------------Class: Spots--------------------------------------------------- #
 class Spots(object):
     def __init__(self, spots_df, config):
         self._parent_cell_prob = None
         self._parent_cell_id = None
+        self.Dist = None
         self.config = config
         self.data = self.read(spots_df)
         self.nS = self.data.shape[0]
         self.unique_gene_names = None
         self._gamma_bar = None
         self._log_gamma_bar = None
-        [_, self.gene_id, self.counts_per_gene] = np.unique(self.data.gene_name.values, return_inverse=True, return_counts=True)
+        self._gene_id = None
+        self._counts_per_gene = None
+        [_, self.gene_id, self.counts_per_gene] = np.unique(self.data.gene_name.values, return_inverse=True,
+                                                            return_counts=True)
 
     def __getstate__(self):
         # set here attributes to be excluded from serialisation (pickling)
-        # It makes the pickle filesize smaller but maybe this will have to
-        # change in the future.
-        # These two attributes take up a lot of space on the disk:
-        # _gamma_bar and _log_gamma_bar
         # FYI: https://realpython.com/python-pickle-module/
+        # Removing _gamma_bar and _log_gamma_bar because they are delayed
+        # But even if they werent, I would remove them anyway because they
+        # make the pickle file a lot larger!
         attributes = self.__dict__.copy()
         del attributes['_gamma_bar']
         del attributes['_log_gamma_bar']
         return attributes
 
     # -------- PROPERTIES -------- #
     @property
-    def gamma_bar(self):
-        return self._gamma_bar.astype(self.config['dtype'])
+    def gene_id(self):
+        return self._gene_id
+
+    @gene_id.setter
+    def gene_id(self, val):
+        self._gene_id = val.astype(np.int32)
+
+    @property
+    def counts_per_gene(self):
+        return self._counts_per_gene
 
-    @gamma_bar.setter
-    def gamma_bar(self, val):
-        self._gamma_bar = val.astype(self.config['dtype'])
+    @counts_per_gene.setter
+    def counts_per_gene(self, val):
+        self._counts_per_gene = val.astype(np.int32)
+
+    @property
+    def gamma_bar(self):
+        return self._gamma_bar
 
     @property
     def log_gamma_bar(self):
         return self._log_gamma_bar
 
-    @log_gamma_bar.setter
-    def log_gamma_bar(self, val):
-        self._log_gamma_bar = val
-
     @property
     def xy_coords(self):
         lst = list(zip(*[self.data.x, self.data.y]))
-        return np.array(lst)
+        return np.array(lst, dtype=np.float32)
 
     @property
     def parent_cell_prob(self):
         return self._parent_cell_prob
 
     @parent_cell_prob.setter
     def parent_cell_prob(self, val):
@@ -259,15 +239,14 @@
     def parent_cell_id(self):
         return self._parent_cell_id
 
     @parent_cell_id.setter
     def parent_cell_id(self, val):
         self._parent_cell_id = val
 
-
     # -------- METHODS -------- #
     def read(self, spots_df):
         # No need for x_global, y_global to be in the spots_df at first place.
         # Instead of renaming here, you could just use 'x' and 'y' when you
         # created the spots_df
         spots_df = spots_df.rename(columns={'x_global': 'x', 'y_global': 'y'})
 
@@ -277,33 +256,35 @@
         spots_df = spots_df.loc[gene_mask]
         return spots_df.rename_axis('spot_id').rename(columns={'target': 'gene_name'})
 
     def cells_nearby(self, cells: Cells) -> np.array:
         spotYX = self.data[['y', 'x']].values
 
         # for each spot find the closest cell (in fact the top nN-closest cells...)
+        # maybe return Dist instead of setting the attribute here
         nbrs = cells.nn()
-        self.Dist, neighbors = nbrs.kneighbors(spotYX)
+        Dist, neighbors = nbrs.kneighbors(spotYX)
+        self.Dist = Dist.astype(np.float32)
 
         # last column is for misreads.
         neighbors[:, -1] = 0
-        return neighbors
+        return neighbors.astype(np.int32)
 
     def ini_cellProb(self, neighbors, cfg):
         nS = self.data.shape[0]
         nN = cfg['nNeighbors'] + 1
         SpotInCell = self.data.label
         # assert (np.all(SpotInCell.index == neighbors.index))
 
         ## sanity check (this actually needs to be rewritten)
         # mask = np.greater(SpotInCell, 0, where=~np.isnan(SpotInCell))
         # sanity_check = neighbors[mask, 0] + 1 == SpotInCell[mask]
         # assert ~any(sanity_check), "a spot is in a cell not closest neighbor!"
 
-        pSpotNeighb = np.zeros([nS, nN])
+        pSpotNeighb = np.zeros([nS, nN], dtype=np.float32)
         pSpotNeighb[neighbors == SpotInCell.values[:, None]] = 1
         pSpotNeighb[SpotInCell == 0, -1] = 1
 
         ## Add a couple of checks here
         return pSpotNeighb
 
     # def loglik(self, cells, cfg):
@@ -317,25 +298,23 @@
     #     # last column (nN-closest) keeps the misreads,
     #     D[:, -1] = np.log(cfg['MisreadDensity'])
     #
     #     mask = np.greater(self.data.label.values, 0, where=~np.isnan(self.data.label.values))
     #     D[mask, 0] = D[mask, 0] + cfg['InsideCellBonus']
     #     return D
 
-
     def mvn_loglik(self, data, cell_label, cells):
         centroids = cells.centroid.values[cell_label]
         covs = cells.cov[cell_label]
         # param = list(zip(*[data, centroids, covs]))
         # out = [self.loglik_contr(p) for i, p in enumerate(param)]
         # out_2 = [multivariate_normal.logpdf(p[0], p[1], p[2]) for i, p in enumerate(param)]
         out = self.multiple_logpdfs(data, centroids, covs)
         return out
 
-
     def multiple_logpdfs(self, x, means, covs):
         """
         vectorised mvn log likelihood evaluated at multiple pairs of (centroid_1, cov_1), ..., (centroid_N, cov_N)
         Taken from http://gregorygundersen.com/blog/2020/12/12/group-multivariate-normal-pdf/
         """
         # Thankfully, NumPy broadcasts `eigh`.
         vals, vecs = np.linalg.eigh(covs)
@@ -358,15 +337,14 @@
 
         # Compute and broadcast scalar normalizers.
         dim = len(vals[0])
         log2pi = np.log(2 * np.pi)
 
         return -0.5 * (dim * log2pi + mahas + logdets)
 
-
     def zero_class_counts(self, geneNo, pCellZero):
         """
         Gene counts for the zero expressing class
         """
         # for each spot get the ids of the 3 nearest cells
         spotNeighbours = self.parent_cell_id[:, :-1]
 
@@ -376,52 +354,37 @@
         # prob that a spot belongs to a zero expressing cell
         pSpotZero = np.sum(neighbourProb * pCellZero[spotNeighbours], axis=1)
 
         # aggregate per gene id
         TotPredictedZ = np.bincount(geneNo, pSpotZero)
         return TotPredictedZ
 
+    @dask.delayed
     def gammaExpectation(self, rho, beta):
-        '''
+        """
         :param r:
         :param b:
         :return: Expectetation of a rv X following a Gamma(r,b) distribution with pdf
         f(x;\alpha ,\beta )= \frac{\beta^r}{\Gamma(r)} x^{r-1}e^{-\beta x}
-        '''
-
-        # sanity check
-        # assert (np.all(rho.coords['cell_id'].data == beta.coords['cell_id'])), 'rho and beta are not aligned'
-        # assert (np.all(rho.coords['gene_name'].data == beta.coords['gene_name'])), 'rho and beta are not aligned'
-
-        dtype = self.config['dtype']
+        """
         r = rho[:, :, None]
-        if dtype == np.float64:
-            gamma = np.empty(beta.shape)
-            ne.evaluate('r/beta', out=gamma)
-            return gamma
-        else:
-            return (r/beta).astype(dtype)
+        return r / beta
 
+    @dask.delayed
     def logGammaExpectation(self, rho, beta):
-        dtype = self.config['dtype']
-        r = rho[:, :, None].astype(dtype)
-        if dtype == np.float64:
-            logb = np.empty(beta.shape)
-            ne.evaluate("log(beta)", out=logb)
-            return scipy.special.psi(r) - logb
-        else:
-            return scipy.special.psi(r) - np.log(beta).astype(dtype)
+        r = rho[:, :, None]
+        return scipy.special.psi(r) - np.log(beta)
 
 
 # ----------------------------------------Class: SingleCell--------------------------------------------------- #
 class SingleCell(object):
     def __init__(self, scdata: pd.DataFrame, genes: np.array, config):
         self.isMissing = None  # Will be set to False is single cell data are assumed known and given as an input
-                               # otherwise, if they are unknown, this will be set to True and the algorithm will
-                               # try to estimate them
+        # otherwise, if they are unknown, this will be set to True and the algorithm will
+        # try to estimate them
         # self.raw_data = self._raw_data(scdata, genes)
         self.config = config
         self._mean_expression, self._log_mean_expression = self._setup(scdata, genes, self.config)
 
     def _setup(self, scdata, genes, config):
         """
         calcs the mean (and the log-mean) gene counts per cell type. Note that
@@ -438,19 +401,18 @@
             self.isMissing = True
         else:
             expr = self._raw_data(scdata, genes)
             self.isMissing = False
 
         self.raw_data = expr
         me, lme = self._helper(expr.copy())
-        dtype = self.config['dtype']
 
         assert me.columns[-1] == 'Zero', "Last column should be the Zero class"
         assert lme.columns[-1] == 'Zero', "Last column should be the Zero class"
-        return me.astype(dtype), lme.astype(dtype)
+        return me.astype(np.float32), lme.astype(np.float32)
 
     # -------- PROPERTIES -------- #
     @property
     def mean_expression(self):
         assert self._mean_expression.columns[-1] == 'Zero', "Last column should be the Zero class"
         return self._mean_expression
 
@@ -479,16 +441,14 @@
         :return:
         """
         out = df.loc[:, (df != 0).any(axis=0)]
         return out
 
     def _helper(self, expr):
         # order by column name
-        # expr = expr.copy().sort_index(axis=0).sort_index(axis=1, key=lambda x: x.str.lower())
-        # expr = expr.copy().sort_index(axis=0).sort_index(axis=1, key=natsort_keygen())
         expr = expr.copy().sort_index(axis=0).sort_index(axis=1, key=natsort_keygen(key=lambda y: y.str.lower()))
 
         # append at the end the Zero class
         expr['Zero'] = np.zeros([expr.shape[0], 1])
 
         # expr = self.config['Inefficiency'] * arr
         me = expr.rename_axis('gene_name').rename_axis("class_name", axis="columns")  # mean expression
@@ -519,62 +479,49 @@
         zero_col = np.zeros(me.shape[0]) + self.config['SpotReg']
         me = me.assign(Zero=zero_col)
         # For the mean of the log-expressions, again only the prior is used for the Zero class
         zero_col_2 = scipy.special.psi(m * zero_col) - np.log(m)
         lme = lme.assign(Zero=zero_col_2)
         return me, lme
 
-    def _keep_labels_unique(self, scdata):
-        """
-        In the single cell data you might find cases where two or more rows have the same gene label
-        In these cases keep the row with the highest total gene count
-        """
-
-        # 1. get the row total and assign it to a new column
-        scdata = scdata.assign(total=scdata.sum(axis=1))
-
-        # 2. rank by gene label and total gene count and keep the one with the highest total
-        scdata = scdata.sort_values(['gene_name', 'total'], ascending=[True, False]).groupby('gene_name').head(1)
-
-        # 3. Drop the total column and return
-        return scdata.drop(['total'], axis=1)
-
     def _raw_data(self, scdata, genes):
         """
         Reads the raw single data, filters out any genes outside the gene panel and then it
         groups by the cell type
         """
         assert np.all(scdata >= 0), "Single cell dataframe has negative values"
-        datatypes_logger.info('Single cell data passed-in have %d genes and %d cells' % (scdata.shape[0], scdata.shape[1]))
+        datatypes_logger.info(
+            'Single cell data passed-in have %d genes and %d cells' % (scdata.shape[0], scdata.shape[1]))
 
         datatypes_logger.info('Single cell data: Keeping counts for the gene panel of %d only' % len(genes))
         df = scdata.loc[genes]
 
         # set the axes labels
         df = self._set_axes(df)
 
         # remove any rows with the same gene label
-        df = self._keep_labels_unique(df)
+        df = keep_labels_unique(df)
 
         df = self._remove_zero_cols(df.copy())
         dfT = df.T
 
         datatypes_logger.info('Single cell data: Grouping gene counts by cell type. Aggregating function is the mean.')
         out = dfT.groupby(dfT.index.values).agg('mean').T
         datatypes_logger.info('Grouped single cell data have %d genes and %d cell types' % (out.shape[0], out.shape[1]))
         return out
 
     def _diag(self, genes):
         # logger.info('******************************************************')
         # logger.info('*************** DIAGONAL SINGLE CELL DATA ***************')
         # logger.info('******************************************************')
         nG = len(genes)
-        mgc = self.config['mean_gene_counts_per_class']  # the avg gene count per cell. Better expose that so it can be set by the user.
+        mgc = self.config[
+            'mean_gene_counts_per_class']  # the avg gene count per cell. Better expose that so it can be set by the user.
         arr = mgc * np.eye(nG)
-        labels = ['class_%d' % (i+1) for i, _ in enumerate(genes)]
+        labels = ['class_%d' % (i + 1) for i, _ in enumerate(genes)]
         df = pd.DataFrame(arr).set_index(genes)
         df.columns = labels
         return df
 
 
 # ---------------------------------------- Class: CellType --------------------------------------------------- #
 class CellType(object):
@@ -627,13 +574,9 @@
         """
         return cells.classProb.sum(axis=0)
 
     def ini_prior(self):
         self.alpha = self.ini_alpha()
 
     def ini_alpha(self):
-        return np.append(np.ones(self.nK - 1), sum(np.ones(self.nK - 1)))
-
-
-
-
-
+        ones = np.ones(self.nK - 1)
+        return np.append(ones, sum(ones)).astype(np.float32)
```

## pciSeq/src/core/main.py

```diff
@@ -29,32 +29,37 @@
         self.nS = self.spots.nS  # number of spots
         self.nN = self.config['nNeighbors'] + 1  # number of closest nearby cells, candidates for being parent
                                                 # cell of any given spot. The last cell will be used for the
                                                 # misread spots. (ie cell at position nN is the background)
         self.iter_num = None
         self.iter_delta = []
         self.has_converged = False
+        self._scaled_exp = None
+
+    @property
+    def scaled_exp(self):
+        return self._scaled_exp
 
     def __getstate__(self):
         # set here attributes to be excluded from serialisation (pickling)
         # It makes the pickle filesize smaller but maybe this will have to
         # change in the future.
-        # Removing redis so I can pickle
+        # Removing redis so I can pickle and _scaled_exp because it is delayed
         # FYI: https://realpython.com/python-pickle-module/
         attributes = self.__dict__.copy()
         del attributes['redis_db']
+        del attributes['_scaled_exp']
         return attributes
 
     def initialise(self):
         self.cellTypes.ini_prior()
         self.cells.classProb = np.tile(self.cellTypes.prior, (self.nC, 1))
         self.genes.init_eta(1, 1 / self.config['Inefficiency'])
         self.spots.parent_cell_id = self.spots.cells_nearby(self.cells)
         self.spots.parent_cell_prob = self.spots.ini_cellProb(self.spots.parent_cell_id, self.config)
-        self.spots.gamma_bar = np.ones([self.nC, self.nG, self.nK]).astype(self.config['dtype'])
 
     # -------------------------------------------------------------------- #
     def run(self):
         p0 = None
         cell_df = None
         gene_df = None
         max_iter = self.config['max_iter']
@@ -65,36 +70,33 @@
 
             # 1. For each cell, calc the expected gene counts
             self.geneCount_upd()
 
             # 2. calc expected gamma
             self.gamma_upd()
 
-            # 6.1 update correlation matrix and variance of the gaussian distribution
-            if self.config['InsideCellBonus'] is False:
+            # 3 update correlation matrix and variance of the gaussian distribution
+            if self.single_cell.isMissing or (self.config['InsideCellBonus'] is False):
                 self.gaussian_upd()
 
-            # 3. assign cells to cell types
+            # 4. assign cells to cell types
             self.cell_to_cellType()
 
-            # 4. assign spots to cells
+            # 5. assign spots to cells
             self.spots_to_cell()
 
-            # 5. update gene efficiency
+            # 6. update gene efficiency
             self.eta_upd()
 
-            # 6. update the dirichlet distribution
-            if self.single_cell.isMissing or self.config['cell_type_prior'] == 'weighted':
+            # 7. update the dirichlet distribution
+            if self.single_cell.isMissing or (self.config['cell_type_prior'] == 'weighted'):
                 self.dalpha_upd()
 
-            # 7. Update single cell data
+            # 8. Update single cell data
             if self.single_cell.isMissing:
-                # 6.2 update the dirichlet distribution
-                self.dalpha_upd()
-                # 6.3 update single cell data
                 self.mu_upd()
 
             self.has_converged, delta = utils.hasConverged(self.spots, p0, self.config['CellCallTolerance'])
             main_logger.info('Iteration %d, mean prob change %f' % (i, delta))
 
             # keep track of the deltas
             self.iter_delta.append(delta)
@@ -138,70 +140,71 @@
         # is the gene counts of gene g within cell c
         N_cg = npg.aggregate(group_idx, probs, size=(self.nC, self.nG))
 
         # assert N_cg.sum() == self.spots.data.shape[0], \
         #     "The sum of the background spots and the cell gene counts should be equal to the total number of spots"
 
         # make output. This part needs to be rewritten
-        out = np.zeros([self.nC, self.nG])
+        out = np.zeros([self.nC, self.nG], dtype=np.float32)
         out[1:, :] = N_cg[1:, :]
 
         # cell at position zero is the background
         self.cells.background_counts = N_cg[0, :]
         # Actual cells are on non-zero positions
         self.cells.geneCount = out
 
     # -------------------------------------------------------------------- #
     def gamma_upd(self):
         """
          Implements equation (3) of the Qian paper
         """
         cells = self.cells
         cfg = self.config
-        dtype = self.config['dtype']
-        beta = np.einsum('c, gk, g -> cgk', cells.ini_cell_props['area_factor'], self.single_cell.mean_expression,
-                         self.genes.eta_bar).astype(dtype) + cfg['rSpot']
-        # beta = np.einsum('c, gk -> cgk', cells.cell_props['area_factor'], self.single_cell.mean_expression).astype(dtype) + cfg['rSpot']
+
+        self._scaled_exp = utils.scaled_exp(cells.ini_cell_props['area_factor'],
+                                            self.single_cell.mean_expression.values,
+                                            self.genes.eta_bar)
+
+        beta = self.scaled_exp.compute() + cfg['rSpot']
         rho = cfg['rSpot'] + cells.geneCount
 
-        self.spots.gamma_bar = self.spots.gammaExpectation(rho, beta)
-        self.spots.log_gamma_bar = self.spots.logGammaExpectation(rho, beta)
+        self.spots._gamma_bar = self.spots.gammaExpectation(rho, beta)
+        self.spots._log_gamma_bar = self.spots.logGammaExpectation(rho, beta)
 
     # -------------------------------------------------------------------- #
     def cell_to_cellType(self):
         """
         return a an array of size numCells-by-numCellTypes where element in position [i,j]
         keeps the probability that cell i has cell type j
         Implements equation (2) of the Qian paper
         :param spots:
         :param config:
         :return:
         """
 
-        dtype = self.config['dtype']
-        ScaledExp = np.einsum('c, g, gk -> cgk', self.cells.ini_cell_props['area_factor'], self.genes.eta_bar,
-                              self.single_cell.mean_expression).astype(dtype)
+        ScaledExp = self.scaled_exp.compute()
         pNegBin = ScaledExp / (self.config['rSpot'] + ScaledExp)
         cgc = self.cells.geneCount
         contr = utils.negBinLoglik(cgc, self.config['rSpot'], pNegBin)
         wCellClass = np.sum(contr, axis=1) + self.cellTypes.log_prior
-        pCellClass = utils.softmax(wCellClass, axis=1)
+        pCellClass = softmax(wCellClass, axis=1)
+        del contr
 
         self.cells.classProb = pCellClass
 
     # -------------------------------------------------------------------- #
     def spots_to_cell(self):
         """
         spot to cell assignment.
         Implements equation (4) of the Qian paper
         """
         nN = self.nN
         nS = self.spots.data.gene_name.shape[0]
 
-        wSpotCell = np.zeros([nS, nN])
+        wSpotCell = np.zeros([nS, nN], dtype=np.float32)
         gn = self.spots.data.gene_name.values
         expected_counts = self.single_cell.log_mean_expression.loc[gn].values
         logeta_bar = self.genes.logeta_bar[self.spots.gene_id]
 
         # loglik = self.spots.loglik(self.cells, self.config)
 
         # pre-populate last column
@@ -214,16 +217,16 @@
 
             # get the respective cell type probabilities
             cp = self.cells.classProb[sn]
 
             # multiply and sum over cells
             term_1 = np.einsum('ij, ij -> i', expected_counts, cp)
 
-            # logger.info('genes.spotNo should be something like spots.geneNo instead!!')
-            log_gamma_bar = self.spots.log_gamma_bar[self.spots.parent_cell_id[:, n], self.spots.gene_id]
+            log_gamma_bar = self.spots.log_gamma_bar.compute()
+            log_gamma_bar = log_gamma_bar[self.spots.parent_cell_id[:, n], self.spots.gene_id]
 
             term_2 = np.einsum('ij, ij -> i', cp, log_gamma_bar)
 
             # wSpotCell[:, n] = term_1 + term_2 + logeta_bar + loglik[:, n]
             mvn_loglik = self.spots.mvn_loglik(self.spots.xy_coords, sn, self.cells)
             wSpotCell[:, n] = term_1 + term_2 + logeta_bar + mvn_loglik
 
@@ -251,15 +254,15 @@
         grand_total = self.cells.background_counts.sum() + self.cells.total_counts.sum()
         assert round(grand_total) == self.spots.data.shape[0], \
             'The sum of the background spots and the total gene counts should be equal to the number of spots'
 
         classProb = self.cells.classProb
         mu = self.single_cell.mean_expression
         area_factor = self.cells.ini_cell_props['area_factor']
-        gamma_bar = self.spots.gamma_bar
+        gamma_bar = self.spots.gamma_bar.compute()
 
         zero_prob = classProb[:, -1]  # probability a cell being a zero expressing cell
         zero_class_counts = self.spots.zero_class_counts(self.spots.gene_id, zero_prob)
 
         # Calcs the sum in the Gamma distribution (equation 5). The zero class
         # is excluded from the sum, hence the arrays in the einsum below stop at :-1
         # Note. I also think we should exclude the "cell" that is meant to keep the
@@ -340,21 +343,21 @@
         denom[:, 0, 0] = N_c + nu_0
         # Note: need to add code to handle the case N_c + nu_0 <= d + 2
         cov = (S + S_0) / denom
 
         # shrinkage
         delta = 0.5
         cov = delta * cov_0 + (1 - delta) * cov
-        self.cells.cov = cov
+        self.cells.cov = cov.astype(np.float32)
 
     # -------------------------------------------------------------------- #
     def mu_upd(self):
         classProb = self.cells.classProb[1:, :-1].copy()
         geneCount = self.cells.geneCount[1:, :].copy()
-        gamma_bar = self.spots.gamma_bar[1:, :, :-1].copy()
+        gamma_bar = self.spots.gamma_bar.compute()[1:, :, :-1]
         area_factor = self.cells.ini_cell_props['area_factor'][1:]
 
         numer = np.einsum('ck, cg -> gk', classProb, geneCount)
         denom = np.einsum('ck, c, cgk, g -> gk', classProb, area_factor, gamma_bar, self.genes.eta_bar)
 
         me, lme = self.single_cell._gene_expressions(numer, denom)
         self.single_cell._mean_expression = me
```

## pciSeq/src/core/utils.py

```diff
@@ -1,89 +1,38 @@
 import sys
 import tempfile, shutil
 from tqdm import tqdm
 from urllib.parse import urlparse
 from urllib.request import urlopen
 import numpy as np
 import pandas as pd
-import numexpr as ne
-# import numba as nb
+import dask
 import os
 import glob
 import subprocess
 from email.parser import BytesHeaderParser
 import logging
 
 utils_logger = logging.getLogger(__name__)
 
 
 def negBinLoglik(x, r, p):
-    '''
+    """
     Negative Binomial loglikehood
     :param x:
     :param r:
     :param p:
     :return:
-    '''
-
-    # sanity check
-    # assert (np.all(da_x.coords['cell_id'].data == da_p.coords['cell_id'])), 'gene counts and beta probabilities are not aligned'
-    # assert (np.all(da_x.coords['gene_name'].data == da_p.coords['gene_name'])), 'gene counts and beta probabilities are not aligned'
+    """
 
-    contr = np.zeros(p.shape)
     x = x[:, :, None]
-    ne.evaluate("x * log(p) + r * log(1 - p)", out=contr)
+    contr = x * np.log(p) + r * np.log(1 - p)
     return contr
 
 
-def softmax(X, theta = 1.0, axis = None):
-    """
-    From https://nolanbconaway.github.io/blog/2017/softmax-numpy
-    Compute the softmax of each element along an axis of X.
-
-    Parameters
-    ----------
-    X: ND-Array. Probably should be floats.
-    theta (optional): float parameter, used as a multiplier
-        prior to exponentiation. Default = 1.0
-    axis (optional): axis to compute values along. Default is the
-        first non-singleton axis.
-
-    Returns an array the same size as X. The result will sum to 1
-    along the specified axis.
-    """
-
-    # make X at least 2d
-    y = np.atleast_2d(X)
-
-    # find axis
-    if axis is None:
-        axis = next(j[0] for j in enumerate(y.shape) if j[1] > 1)
-
-    # multiply y against the theta parameter,
-    y = y * float(theta)
-
-    # subtract the max for numerical stability
-    y = y - np.expand_dims(np.max(y, axis = axis), axis)
-
-    # exponentiate y
-    y = np.exp(y)
-
-    # take the sum along the specified axis
-    ax_sum = np.expand_dims(np.sum(y, axis = axis), axis)
-
-    # finally: divide elementwise
-    p = y / ax_sum
-
-    # flatten if X was 1D
-    if len(X.shape) == 1: p = p.flatten()
-
-    return p
-
-
 def hasConverged(spots, p0, tol):
     p1 = spots.parent_cell_prob
     if p0 is None:
         p0 = np.zeros(p1.shape)
     delta = np.max(np.abs(p1 - p0))
     converged = (delta < tol)
     return converged, delta
@@ -107,16 +56,16 @@
 
     n = 0
     size = None
     header_line = next(handle)
     file_out, handle_out = _get_file(OUT_DIR, filepath, n, header_line)
     for line in handle:
         size = os.stat(file_out).st_size
-        if size > mb_size*1024*1024:
-            utils_logger.info('saved %s with file size %4.3f MB' % (file_out, size/(1024*1024)))
+        if size > mb_size * 1024 * 1024:
+            utils_logger.info('saved %s with file size %4.3f MB' % (file_out, size / (1024 * 1024)))
             n += 1
             handle_out.close()
             file_out, handle_out = _get_file(OUT_DIR, filepath, n, header_line)
         handle_out.write(str(line))
 
     # print(str(file_out) + " file size = \t" + str(size))
     print('saved %s with file size %4.3f MB' % (file_out, size / (1024 * 1024)))
@@ -141,22 +90,22 @@
     else:
         df = None
 
     df_list = np.array_split(df, n)
     if not os.path.exists(OUT_DIR):
         os.makedirs(OUT_DIR)
     else:
-        files = glob.glob(OUT_DIR + '/*.'+ext)
+        files = glob.glob(OUT_DIR + '/*.' + ext)
         for f in files:
             os.remove(f)
 
     for i, d in enumerate(df_list):
         fname = os.path.join(OUT_DIR, filename + '_%d.%s' % (i, ext))
         if ext == 'json':
-            d.to_json(fname,  orient='records')
+            d.to_json(fname, orient='records')
         elif ext == 'tsv':
             d.to_csv(fname, sep='\t', index=False)
 
 
 def _get_file(OUT_DIR, filepath, n, header_line):
     [filename, ext] = os.path.basename(filepath).split('.')
     file = os.path.join(OUT_DIR, filename + '_%d.%s' % (n, ext))
@@ -276,8 +225,69 @@
     eigvals, eigvecs = np.linalg.eig(cov)
     eigvals = sdwidth * np.sqrt(eigvals)
     eigvals = eigvals * np.eye(2)
 
     vd = eigvecs.dot(eigvals)
     out = vd.dot(ap) + mu.reshape(2, -1)
 
-    return np.array(list(zip(*out)))
+    return np.array(list(zip(*out)), dtype=np.float32)
+
+
+def read_image_objects(img_obj, cfg):
+    meanCellRadius = np.mean(np.sqrt(img_obj.area / np.pi)) * 0.5
+    relCellRadius = np.sqrt(img_obj.area / np.pi) / meanCellRadius
+
+    # append 1 for the misreads
+    relCellRadius = np.append(1, relCellRadius)
+
+    InsideCellBonus = cfg['InsideCellBonus']
+    if not InsideCellBonus:
+        # This is more for clarity. The operation below will work fine even if InsideCellBonus is False
+        InsideCellBonus = 0
+
+    # if InsideCellBonus == 0 then CellAreaFactor will be equal to 1.0
+    numer = np.exp(-relCellRadius ** 2 / 2) * (1 - np.exp(InsideCellBonus)) + np.exp(InsideCellBonus)
+    denom = np.exp(-0.5) * (1 - np.exp(InsideCellBonus)) + np.exp(InsideCellBonus)
+    CellAreaFactor = numer / denom
+
+    out = {}
+    out['area_factor'] = CellAreaFactor.astype(np.float32)
+    out['rel_radius'] = relCellRadius.astype(np.float32)
+    out['area'] = np.append(np.nan, img_obj.area.astype(np.uint32))
+    out['x0'] = np.append(-sys.maxsize, img_obj.x0.values).astype(np.float32)
+    out['y0'] = np.append(-sys.maxsize, img_obj.y0.values).astype(np.float32)
+    out['cell_label'] = np.append(0, img_obj.label.values).astype(np.uint32)
+    if 'old_label' in img_obj.columns:
+        out['cell_label_old'] = np.append(0, img_obj.old_label.values).astype(np.uint32)
+    # First cell is a dummy cell, a super neighbour (ie always a neighbour to any given cell)
+    # and will be used to get all the misreads. It was given the label=0 and some very small
+    # negative coords
+
+    return out, meanCellRadius.astype(np.float32)
+
+
+def keep_labels_unique(scdata):
+    """
+    In the single cell data you might find cases where two or more rows have the same gene label
+    In these cases keep the row with the highest total gene count
+    """
+
+    # 1. get the row total and assign it to a new column
+    scdata = scdata.assign(total=scdata.sum(axis=1))
+
+    # 2. rank by gene label and total gene count and keep the one with the highest total
+    scdata = scdata.sort_values(['gene_name', 'total'], ascending=[True, False]).groupby('gene_name').head(1)
+
+    # 3. Drop the total column and return
+    return scdata.drop(['total'], axis=1)
+
+
+@dask.delayed
+def scaled_exp(cell_area_factor, sc_mean_expressions, inefficiency):
+    if np.all(cell_area_factor == 1):
+        subscripts = 'gk, g -> gk'
+        operands = [sc_mean_expressions, inefficiency]
+    else:
+        subscripts = 'c, gk, g -> cgk'
+        operands = [cell_area_factor, sc_mean_expressions, inefficiency]
+    out = np.einsum(subscripts, *operands)
+    return out
```

## pciSeq/src/diagnostics/launch_diagnostics.py

```diff
@@ -1,19 +1,48 @@
 import os
+from pathlib import Path
+import tomlkit
 import subprocess
 import pciSeq.src.diagnostics.utils as utils
 import logging
 
 launch_diagnostics_logger = logging.getLogger(__name__)
 
 
 def launch_dashboard():
     dirname = os.path.dirname(__file__)
     filename = os.path.join(dirname, 'diagnostics.py')
     code_1, code_2 = utils.validate_redis()
     if code_1 == 0 and code_2 == 0:
+        make_credentials()
         p = subprocess.Popen(["streamlit", "run", filename, " --server.headless true"])
         # TODO: you need to kill the process on exit
-        # logger.info('Starting process with pid: %d to run the diagnostics' % p.pid)
+        # launch_diagnostics_logger.info('Starting process with pid: %d to run the diagnostics' % p.pid)
     else:
         launch_diagnostics_logger.info("Skipping diagnostics, cannot run them. Either redis not installed or not running.")
 
+
+def make_credentials():
+    """
+    creates a credentials.toml file in the .streamlit folder under the user's home dir and
+    in the [general] section it creates an email key with value an empty string.
+    If an email key/value pair exists already, the file remains intact.
+    The only purpose of this is to skip the annoying streamlit welcome message so that
+    the diagnostics will be launched without any user interaction. (otherwise the welcome msg
+    might pause the program flow)
+    """
+    credentials = os.path.join(Path.home(), '.streamlit', 'credentials.toml')
+    Path(credentials).parent.mkdir(parents=True, exist_ok=True)
+    mode = 'rt' if os.path.exists(credentials) else 'w+'
+    with open(credentials, mode) as fp:
+        doc = tomlkit.load(fp)
+        append_email(doc, credentials)
+
+
+def append_email(doc, fname):
+    if doc.get('general') is None:
+        general = tomlkit.table()
+        doc.add("general", general)
+    if doc.get('general').get('email') is None:
+        doc.get('general').add("email", "")
+    with open(fname, 'w') as outfile:
+        tomlkit.dump(doc, outfile)
```

## pciSeq/src/preprocess/cell_borders.py

```diff
@@ -1,14 +1,25 @@
 """ Functions to extract the cell boundaries """
 import pandas as pd
 import numpy as np
-import diplib as dip
 from multiprocessing import Pool, cpu_count
 from multiprocessing.dummy import Pool as ThreadPool
 
+# All that below is to avoid diplib to show a welcome msg on import. If hasattr(sys,'ps1') return True, then
+# import diplib will print out the diplib name, version, description which I find annoying. I am deleting ps1
+# and then reinstate it after the import.
+try:
+    import sys
+    ps1 = sys.__dict__['ps1']
+    del sys.ps1
+    import diplib as dip
+    sys.__dict__['ps1'] = ps1
+except KeyError:
+    import diplib as dip
+
 
 def extract_borders_dip(label_image, offset_x=0, offset_y=0, exclude_labels=(0,)):
     """
     Extracts the cell boundaries from the label image array. The background is
     assumed to have label=0 and it will be ignored by default.
     Parameters
     ----------
```

## pciSeq/src/preprocess/spot_labels.py

```diff
@@ -21,15 +21,15 @@
     elif isinstance(label_image, np.ndarray):
         label_image = csr_matrix(label_image)
     elif isinstance(label_image, csr_matrix):
         pass
     else:
         raise Exception('label_image should be of type "csr_matrix" ')
     m = label_image[spots.y, spots.x]
-    out = np.asarray(m)
+    out = np.asarray(m, dtype=np.uint32)
     return out[0]
 
 
 def remap_labels(coo):
     """
     Used for debugging/sanity checking only. It resuffles the label_image
     """
@@ -47,15 +47,18 @@
     """
     rearranges the labels so that they are a sequence of integers
     """
     label_image = coo.toarray()
     flat_arr = label_image.flatten()
     u, idx = np.unique(flat_arr, return_inverse=True)
 
-    label_map = pd.DataFrame(set(zip(flat_arr, idx)), columns=['old_label', 'new_label'])
+    label_map = pd.DataFrame(
+        set(zip(flat_arr, idx)),
+        columns=['old_label', 'new_label'],
+        dtype=np.uint32)
     label_map = label_map.sort_values(by='old_label', ignore_index=True)
     return coo_matrix(idx.reshape(label_image.shape)), label_map
 
 
 def stage_data(spots: pd.DataFrame, coo: coo_matrix) -> Tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame]:
     """
     Reads the spots and the label image that are passed in and calculates which cell (if any) encircles any
@@ -72,26 +75,32 @@
     spot_labels_logger.info('Number of segmented cells: %d' % len(set(coo.data)))
     spot_labels_logger.info('Segmentation array implies that image has width: %dpx and height: %dpx' % (coo.shape[1], coo.shape[0]))
     mask_x = (spots.x >= 0) & (spots.x <= coo.shape[1])
     mask_y = (spots.y >= 0) & (spots.y <= coo.shape[0])
     spots = spots[mask_x & mask_y]
 
     # 1. Find which cell the spots lie within
-    inc = inside_cell(coo.tocsr(), spots)
+    inc = inside_cell(coo.tocsr().astype(np.uint32), spots)
     spots = spots.assign(label=inc)
 
     # 2. Get cell centroids and area
     props = skmeas.regionprops_table(coo.toarray().astype(np.int32), properties=['label', 'area', 'centroid'])
     props_df = pd.DataFrame(props).rename(columns={'centroid-0': 'y_cell', 'centroid-1': 'x_cell'})
 
     # if there is a label map, attach it to the cell props.
     if label_map is not None:
         props_df = pd.merge(props_df, label_map, left_on='label', right_on='new_label', how='left')
         props_df = props_df.drop(['new_label'], axis=1)
 
+    # set the datatypes of the columns
+    props_df = props_df.astype({"label": np.uint32,
+                                "area": np.uint32,
+                                'y_cell': np.float32,
+                                'x_cell': np.float32})
+
     # 3. Get the cell boundaries
     # cell_boundaries = extract_borders_dip(coo.toarray().astype(np.uint32))
     cell_boundaries = extract_borders(coo.toarray().astype(np.uint32))
     assert props_df.shape[0] == cell_boundaries.shape[0] == np.unique(coo.data).shape[0]
     assert set(spots.label[spots.label > 0]) <= set(props_df.label)
 
     cells = props_df.merge(cell_boundaries)
```

## pciSeq/static/2D/viewer/genes_datatable.html

```diff
@@ -44,20 +44,39 @@
         </tr>
         </thead>
     </table>
     <hr>
 
 
 <script>
+
+    function get_color(gene_name){
+        var o = []
+        o = glyphSettings().filter(d=>d.gene === gene_name)
+        if (o.length === 0 ){
+            return get_color('Generic')
+        }
+        return o[0].color
+    }
+
+   function get_glyphName(gene_name){
+        let o
+        o = glyphSettings().filter(d=>d.gene === gene_name)
+        if (o.length === 0 ){
+            return get_color('Generic')
+        }
+        return o[0].glyphName
+    }
+
+
     sessionStorage['dtCompleted'] =  0;
     var table;
     $(document).ready(function () {
         var gene_panel = JSON.parse(sessionStorage.getItem('gene_panel'));
-        var legendData = glyphSettings().filter(d => gene_panel.includes(d.gene))
-          .map((d,i) => {return [i, d.gene, d.glyphName, d.color]});
+        var legendData = gene_panel.map((d, i) => [i, d, get_glyphName(d), get_color(d)])
         table = $('#example').DataTable({
             'data': legendData,
             'columnDefs': [
                 {
                     'targets': 0,
                     'checkboxes': {
                         'selectRow': true,
```

## pciSeq/static/2D/viewer/js/classConfig.js

### js-beautify {}

```diff
@@ -310,15 +310,15 @@
         {
             className: 'Generic',
             IdentifiedType: 'Generic',
             color: '#C0C0C0'
         },
 
         // The donut chart at the bottom right will aggregate all classes with prob < 2% under the Other
-        // label (see line 278, donut.js)
+        // label (see line 284, donut.js)
         {
             className: 'Other',
             IdentifiedType: 'Other',
             color: '#C0C0C0'
         },
```

## pciSeq/static/2D/viewer/js/dapi.js

### js-beautify {}

```diff
@@ -88,14 +88,19 @@
         } else {
             out = glyphMap.get('Generic').color
         }
         console.log(out)
         return out
     }
 
+    function getIdentifiedType(class_name) {
+        return classColorsMap.get(class_name) ? classColorsMap.get(class_name).IdentifiedType : classColorsMap.get('Generic').IdentifiedType
+    }
+
+
     // get the svg markers (glyphs)
     var glyphs = glyphSettings();
     var glyphMap = d3.map(glyphs, function(d) {
         return d.gene;
     });
 
     //get the class colors
@@ -224,15 +229,15 @@
         var out = '';
         var temp = [];
         var sdata = [];
         if (cellFeatures) {
             for (var i = 0; i < cellFeatures.ClassName.length; ++i) {
                 temp.push({
                     ClassName: cellFeatures.ClassName[i],
-                    IdentifiedType: classColorsMap.get(cellFeatures.ClassName[i]).IdentifiedType,
+                    IdentifiedType: getIdentifiedType(cellFeatures.ClassName[i]),
                     Prob: cellFeatures.Prob[i],
                 })
             }
 
             temp = d3.nest()
                 .key(function(d) {
                     return d.IdentifiedType;
```

## pciSeq/static/2D/viewer/js/donut.js

### js-beautify {}

```diff
@@ -61,25 +61,31 @@
     // var colors = ["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"];
     // var colors = d3.schemeCategory20
     var colorRamp = classColorsCodes()
     var colorMap = d3.map(colorRamp, function(d) {
         return d.className;
     });
 
+    function getColor(class_name) {
+        return colorMap.get(class_name) ? colorMap.get(class_name).color : colorMap.get('Generic').color
+    }
+
+
     var div = d3.select("body").append("div")
         .attr("class", "toolTip")
         .style('opacity', 0);
 
     var donutData = {};
     donutData.radius = radius;
     donutData.pie = pie;
     donutData.arc = arc;
     donutData.outerArc = outerArc;
     donutData.key = key;
     donutData.colorMap = colorMap;
+    donutData.getColor = getColor;
     donutData.div = div;
     donutData.svg = svg;
 
 
     return donutData;
 
 }
@@ -348,15 +354,15 @@
         .on("mousemove", mousemoveHandler)
         .on("mouseout", function(d) {
             donutData.div.style("display", "none");
         })
         .merge(slice)
         //.style("fill", 'url(#myPattern)')
         .style("fill", function(d) {
-            return donutData.colorMap.get(d.data.label).color;
+            return donutData.getColor(d.data.label);
         })
         .transition().duration(1000)
         .attrTween("d", function(d) {
             this._current = this._current || d;
             var interpolate = d3.interpolate(this._current, d);
             this._current = interpolate(0);
             return function(t) {
```

## pciSeq/static/2D/viewer/js/stage_glyphs.js

### js-beautify {}

```diff
@@ -1,20 +1,22 @@
 function _removeOverlay(name) {
+    // removes the glyphs from the map when leaflet is in control
     if (geneOverlays) {
         var el = geneOverlays.filter(d => d.geneName === name);
-        if (el) {
+        if (el.length > 0) {
             geneLayers.removeLayer(el[0].geneLayer)
         }
     }
 }
 
 function _addOverlay(name) {
+    // adds the glyphs to the map when leaflet is in control
     if (geneOverlays) {
         var el = geneOverlays.filter(d => d.geneName === name);
-        if (el) {
+        if (el.length > 0) {
             geneLayers.addLayer(el[0].geneLayer)
         }
     }
 }
 
 function refresh() {
     // if localStorage hide the relevant layers
@@ -57,23 +59,22 @@
         }
     }
 
 
 
     function renderChart(geneData) {
         myDots = make_dots(geneData);
-        geneData = null; //delete geneData, not needed anymore
         geneOverlays = []; // gene to layer map
         console.log('New dot layer added!')
 
         console.log('Adding geneLayers')
         dapiConfig.removeLayer(geneLayers);
         geneLayers = new L.LayerGroup().addTo(map);
         //create marker layer and display it on the map
-        var genes = glyphSettings().map(d => d.gene).sort();
+        var genes = [...new Set(geneData.map(d => d.Gene))].sort()
         for (var i = 0; i < genes.length; i += 1) {
             var geneName = genes[i];
             var geneLayer = L.geoJson(myDots, {
                 pointToLayer: function(feature, latlng) {
                     return new svgGlyph(latlng, dapiConfig.style(feature, 'gene')).bindTooltip(feature.properties.Gene, {
                         className: 'myCSSClass'
                     });
```

## Comparing `pciSeq-0.0.61.dev2.dist-info/LICENCE` & `pciSeq-0.0.61.dev3.dist-info/LICENCE`

 * *Files identical despite different names*

## Comparing `pciSeq-0.0.61.dev2.dist-info/METADATA` & `pciSeq-0.0.61.dev3.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,36 +1,37 @@
 Metadata-Version: 2.1
 Name: pciSeq
-Version: 0.0.61.dev2
+Version: 0.0.61.dev3
 Summary: Probabilistic cell typing for spatial transcriptomics
 Home-page: https://github.com/acycliq/pciSeq
 Author: Dimitris Nicoloutsopoulos
 Author-email: dimitris.nicoloutsopoulos@gmail.com
 License: BSD
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: BSD License
 Classifier: Operating System :: OS Independent
 Description-Content-Type: text/markdown
 License-File: LICENCE
-Requires-Dist: numpy-groupies
-Requires-Dist: pandas
-Requires-Dist: scipy
-Requires-Dist: streamlit
 Requires-Dist: altair
-Requires-Dist: scikit-image
-Requires-Dist: scikit-learn
-Requires-Dist: tqdm
-Requires-Dist: flask
+Requires-Dist: dask
+Requires-Dist: diplib
 Requires-Dist: fastremap
+Requires-Dist: flask
+Requires-Dist: natsort
 Requires-Dist: numexpr
-Requires-Dist: diplib
+Requires-Dist: numpy-groupies
+Requires-Dist: pandas
 Requires-Dist: pyvips
-Requires-Dist: natsort
 Requires-Dist: redis
-Requires-Dist: pytest
+Requires-Dist: scikit-image
+Requires-Dist: scikit-learn
+Requires-Dist: scipy
+Requires-Dist: streamlit
+Requires-Dist: tomlkit
+Requires-Dist: tqdm
 Provides-Extra: interactive
 Requires-Dist: matplotlib >=2.2.0 ; extra == 'interactive'
 Requires-Dist: jupyter ; extra == 'interactive'
 
 # pciSeq: Probabilistic Cell typing by In situ Sequencing
 
 [![Actions Status](https://github.com/acycliq/pciSeq/workflows/Run%20tests/badge.svg)](https://github.com/acycliq/pciSeq/actions)
```

## Comparing `pciSeq-0.0.61.dev2.dist-info/RECORD` & `pciSeq-0.0.61.dev3.dist-info/RECORD`

 * *Files 15% similar despite different names*

```diff
@@ -1,49 +1,49 @@
 pciSeq/__init__.py,sha256=EWYlnXKeinABE1C6jfIVmihS6d-DvA2Yw014mZD7sQ4,1731
-pciSeq/_version.py,sha256=4Q7JxYGGZFEKJTq5F_vhveHEqmeSdEIO1cu5XLfkbfk,27
-pciSeq/app.py,sha256=6xP0kIrpfJH8mQ4jlo98TkIPGzRpp_RE01sQW-2sXOE,12064
-pciSeq/config.py,sha256=lpys8Us_SPJH-ue0l4-0mVNsRhagNxA08aIMynD3948,4474
+pciSeq/_version.py,sha256=QrYa5cR-xaPQjYaCUrQaMvUvFdbb26mvhWNrL0_G7oo,27
+pciSeq/app.py,sha256=vxMNswWMxF1cMArnGe8B-j0XaaKOs0o04UdykI6g5is,12905
+pciSeq/config.py,sha256=gjl5V4rs5aAzsvW4k3OmgKcXlzYFzitSdDAvZGljcd0,3912
 pciSeq/src/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 pciSeq/src/core/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-pciSeq/src/core/datatypes.py,sha256=_1OLXigwvRnf67UnYg1aA24mYUyfWaJjiGtiTqxiSq8,23731
+pciSeq/src/core/datatypes.py,sha256=TMh8TmlgPhdgEQF0D_Mv2RySthkUI1TjfWJZNd1JuMI,21229
 pciSeq/src/core/logger.py,sha256=pU4dZvk3djD3Of05CZFS5OeysbQNC4tJhxOJGG7vm4E,588
-pciSeq/src/core/main.py,sha256=X63N68nUVJA6gGAnoL3pa-pXZ6z_F_W-WBoFdTMYzLI,20254
+pciSeq/src/core/main.py,sha256=JX0JWS3zl5BMJ1SXR-67vS5vcT6gjeRO1pOxpNc1A9U,20021
 pciSeq/src/core/summary.py,sha256=_hC5AJCJIceody0ORmlAfdgZOU6lCwlcGbXZVmjDq_I,3330
-pciSeq/src/core/utils.py,sha256=d-u0X2ILzqI9boUijF74rwDZoJ_mh_3pYGpXzT_3LGA,8589
+pciSeq/src/core/utils.py,sha256=v0M3_LHSfPNqxE-wwTU0lwmRyf9EjBJm4uLCqyrqqPg,9656
 pciSeq/src/diagnostics/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 pciSeq/src/diagnostics/config.py,sha256=BWAyohIeABDl-ktYn2OiOoF6U4KBtWyduEbbyCc8Tuc,191
 pciSeq/src/diagnostics/diagnostics.py,sha256=lgMZhnLOTpDcOeq8tbbmEP9oa_aH4ybxm9Mz7ykrNeI,3277
-pciSeq/src/diagnostics/launch_diagnostics.py,sha256=ZW3J44mVHQAGUBAwOam5qQdYOlLlfHHN6KdTDdh6DvQ,708
+pciSeq/src/diagnostics/launch_diagnostics.py,sha256=ITgn0JPc9Og4l86Tx1UYDsjkkTNtao0th5b8FLwo5EU,1904
 pciSeq/src/diagnostics/utils.py,sha256=KeSf5kEUKX5DvIyo7zKhsu6puGfxTeqdN_1Ex15vPV4,7173
 pciSeq/src/preprocess/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-pciSeq/src/preprocess/cell_borders.py,sha256=i2V_FyGOpLUagffVR1ulv9W0hYzEGQ94lUkyyQMJrfU,3356
-pciSeq/src/preprocess/spot_labels.py,sha256=zZmpQIrOEPWU9-vt8l2YqfGE26SfHn2ec7gWQxz_pEU,4603
+pciSeq/src/preprocess/cell_borders.py,sha256=hdiEGqmWv9WLQOe4vUNLGObZpMzb6VmRpBe-yqGeY0o,3760
+pciSeq/src/preprocess/spot_labels.py,sha256=geCGX5hA8cyJ2oCDqjbMgGm5eAue7nbJeSjIRkSIXec,4932
 pciSeq/src/preprocess/utils.py,sha256=eL4XPvHdjrRztPxMNP1TyLGPcyOvb0GRQ3nFUo_ykFk,84
 pciSeq/src/viewer/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 pciSeq/src/viewer/run_flask.py,sha256=WegFZrDzEpvZFVumLYoUbTCkmhRqnVQUefPXKI8fgLY,2151
 pciSeq/src/viewer/stage_image.py,sha256=4A9Kz-_jbSZNIOdqaiarg2ysUOUCbEHUqn5PuPf2TBI,4046
 pciSeq/src/viewer/utils.py,sha256=SbkAceqouFSJGg0JFkNYRswLOc_krrwJtvfQVfditGY,9157
 pciSeq/static/2D/index.html,sha256=N7VFLoyKo5_y8KHky19aEDthXJTFbET9oBJqxB4pjvk,9107
-pciSeq/static/2D/viewer/genes_datatable.html,sha256=1eU-0PnyfxVZIX8XgRCJh63B_M-m30ORzkyjpyjO1d4,6335
+pciSeq/static/2D/viewer/genes_datatable.html,sha256=-5WdR3eIFkzrwZJ-z_DPg4UoqUunVKCICSGGZ80ZoUg,6732
 pciSeq/static/2D/viewer/css/index.css,sha256=sfJpwD9q0Dlnx31nsAELY56kIlXiKR0bU40MjWJ9c40,8479
 pciSeq/static/2D/viewer/css/progress.css,sha256=4M48kQkzwr9PYUQUI3JUVOgPs2ODZS92mK7lG8cMWY8,2977
-pciSeq/static/2D/viewer/js/classConfig.js,sha256=7mWN2K0o58JxpMJN9qAhK_f6_EhFiQ5kPM3Nc-4tIOg,7613
+pciSeq/static/2D/viewer/js/classConfig.js,sha256=OZ7PuANHg5CAu37lQU68CaUBKN9g2CrUvgU7SGIUSog,7613
 pciSeq/static/2D/viewer/js/config.js,sha256=5QK-f5vpHgKuIOfZG-frPJeDf7eklSLkEp888aI6sHY,2337
 pciSeq/static/2D/viewer/js/customControl.js,sha256=hEDB3r-EYJvBsswQnuWjf3M45XfuQgSrWXXNNZnrBTw,5422
-pciSeq/static/2D/viewer/js/dapi.js,sha256=caS52HEBcDMNfAFP528b7t2DQqThIF5esn65SeTAMFo,22862
+pciSeq/static/2D/viewer/js/dapi.js,sha256=ZTi0yGK6pswTqKH6NOkGuROxfR2XRMinY4HZsgRzLrE,23037
 pciSeq/static/2D/viewer/js/dataLoader.js,sha256=5CW9lVuqZ2FQGOxebTuwlve16lBkgxGgxUxJ_DkZVyE,5842
-pciSeq/static/2D/viewer/js/donut.js,sha256=7fYD05xwrsm9FZmBSXcOXLT23h2WyXUgcjRP8X1vYEk,16704
+pciSeq/static/2D/viewer/js/donut.js,sha256=akxLhYucf07MTtBoL8iQT_fEM3_5w1uitpW4Zmzs298,16875
 pciSeq/static/2D/viewer/js/dt.js,sha256=bRY2_2-s_UVAP22Jvg-XDWEgyJaGJSIY_bVJjmWPckw,3986
 pciSeq/static/2D/viewer/js/glyphConfig.js,sha256=Wzw6ceRiz3iOrV41peu9ewHxba_3YyQj83RlIAWdU54,9678
 pciSeq/static/2D/viewer/js/glyphPaths.js,sha256=Uzdgk7yNycahV2x5zPTw-InzDXcTWBA3ZeEz1wj5TQQ,4234
 pciSeq/static/2D/viewer/js/glyphs.js,sha256=Crp6tG0dTWH_IAGFzM6PbL_V9Wi5vFtrXseB20vtz3U,6996
 pciSeq/static/2D/viewer/js/index.js,sha256=qnpBCHW-0frT0KeNRRKVC3nQFZJ8LPjPPnGE1ywQBp0,11916
 pciSeq/static/2D/viewer/js/progress.js,sha256=Z193F7U6HxuHlJfwrOGOxbEYc8omxfFQE2dAayifdsU,1046
 pciSeq/static/2D/viewer/js/stage_cells.js,sha256=7PI8pV1tV3Y8lW64B3lSNhwcuNtsBQE3B2nuLrFzGpI,6206
-pciSeq/static/2D/viewer/js/stage_glyphs.js,sha256=ajv3warMZsfQzfEoES6MrUDzNe15_ud2E8Vb2XaUGak,11715
+pciSeq/static/2D/viewer/js/stage_glyphs.js,sha256=7KY6AHXE-euwvUkyL9f15rrOOQNRu6suTe0NCLT6K7M,11808
 pciSeq/static/2D/viewer/js/stage_markers_patched.js,sha256=FMbD1J-V4COC77tt4BkM5VZGtCtUrT_0uFQlOAU63uc,7408
 pciSeq/static/2D/viewer/js/stage_polygons.js,sha256=teliPl5Zk6kgj_IiODBaPUviF-7EwwBCc4f4bjEM9dA,14941
 pciSeq/static/2D/viewer/js/streaming-tsv-parser.js,sha256=6vE8POoG7YiweENQDmfKIevNGSp3_PlAB4-lVSvpDGQ,4330
 pciSeq/static/2D/viewer/js/viewerUtils.js,sha256=4uhK678THdVL-koXNT4ScgbrVZ1PSa7_cFx4Nf60KM8,4557
 pciSeq/static/2D/viewer/js/lib/css/L.Control.Layers.Tree.css,sha256=Uogm-cNOMN4ZNVgA8SqjGbmXivrOH3eG2pmWE4_cN7k,933
 pciSeq/static/2D/viewer/js/lib/css/Leaflet.Coordinates-0.1.3.css,sha256=W6ZGjm-QrMQy_6C6xfkPA8tgk_Oh6JY3StLhQUrK_fA,421
 pciSeq/static/2D/viewer/js/lib/css/bootstrap.min.css,sha256=MfvZlkHCEqatNoGiOXveE8FIwMzZg4W85qfrfIFBfYc,122540
@@ -57,12 +57,12 @@
 pciSeq/static/2D/viewer/js/lib/js/leaflet-pip.js,sha256=U_EZGeLQZD9guGer3mbbLexgaBFOFQkn72FRS_s-SWE,14928
 pciSeq/static/2D/viewer/js/lib/js/leaflet.textpath.js,sha256=pSkT8DzyOT1hbB2xJxl1wwnBE5h_H8Og5UtDc2hkE18,5753
 pciSeq/static/2D/viewer/js/lib/js/preloader.js,sha256=iDO2GzayAfiSUg5MGnAyRMuvIyDoARt3DpJfO1fonoI,257
 pciSeq/static/2D/viewer/js/lib/js/pixiOverlay/MarkerContainer.js,sha256=W6_y9wkmX83gNhrqES22mEKExz5WcJ8D3DCvikO-_ys,8784
 pciSeq/static/2D/viewer/js/lib/js/pixiOverlay/bezier-easing.js,sha256=q_szOV2ew7Sfn37k7_ZqxWuVfhyyhLjzxqB236D9O7s,4323
 pciSeq/static/2D/viewer/js/lib/js/pixiOverlay/example.min.js,sha256=bZEnK8XSnShrpLYtOS7Xq7wnp-nW_nMZh4aaDc1Gt6U,613808
 pciSeq/static/2D/viewer/js/lib/js/pixiOverlay/tools.min.js,sha256=A027Ub-oWXvKbz2B3pgMFS5xApmnEHXz9GQh79YZZnU,91874
-pciSeq-0.0.61.dev2.dist-info/LICENCE,sha256=2bm9uFabQZ3Ykb_SaSU_uUbAj2-htc6WJQmS_65qD00,1073
-pciSeq-0.0.61.dev2.dist-info/METADATA,sha256=0hVzeyOu_zGSixIg-GCwPiL_aHoJLFRaCO_zEF5o4B8,6325
-pciSeq-0.0.61.dev2.dist-info/WHEEL,sha256=yQN5g4mg4AybRjkgi-9yy4iQEFibGQmlz78Pik5Or-A,92
-pciSeq-0.0.61.dev2.dist-info/top_level.txt,sha256=mSonMN0SaB51m5yLGm5hFE1Fthf-2U4sRKxSezY-JMk,7
-pciSeq-0.0.61.dev2.dist-info/RECORD,,
+pciSeq-0.0.61.dev3.dist-info/LICENCE,sha256=2bm9uFabQZ3Ykb_SaSU_uUbAj2-htc6WJQmS_65qD00,1073
+pciSeq-0.0.61.dev3.dist-info/METADATA,sha256=GBxEx_96zGe__52mm7Va5UIckvuXww6SwLuiD4Qce3A,6346
+pciSeq-0.0.61.dev3.dist-info/WHEEL,sha256=yQN5g4mg4AybRjkgi-9yy4iQEFibGQmlz78Pik5Or-A,92
+pciSeq-0.0.61.dev3.dist-info/top_level.txt,sha256=mSonMN0SaB51m5yLGm5hFE1Fthf-2U4sRKxSezY-JMk,7
+pciSeq-0.0.61.dev3.dist-info/RECORD,,
```

